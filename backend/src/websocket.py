"""
WebSocket handler for voice streaming API.
Generated by qwen2.5-coder:32b, refined by GLaDOS.

Supports:
- Session persistence across reconnects
- Multi-message responses
- Server-initiated messages
"""

import asyncio
import logging
from typing import Dict, Optional, Any, List

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from pydantic import BaseModel, Field
from starlette.websockets import WebSocketState

from .transcribe import ChunkedTranscriber
from .stream_response import stream_chat_response, get_all_responses, get_all_responses_with_progress
from .main import strip_markdown
from .session_store import session_store, start_cleanup_task, Session

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)


# =============================================================================
# Message Types (Client → Server)
# =============================================================================

class AudioStartMessage(BaseModel):
    type: str = "audio_start"
    format: str  # webm, wav, mp4


class AudioEndMessage(BaseModel):
    type: str = "audio_end"


class TextMessage(BaseModel):
    type: str = "text"
    content: str


class CancelMessage(BaseModel):
    type: str = "cancel"


class ReconnectMessage(BaseModel):
    type: str = "reconnect"
    session_id: str


class AckMessage(BaseModel):
    type: str = "ack"
    message_id: str


# =============================================================================
# Message Types (Server → Client)
# =============================================================================

class ReadyMessage(BaseModel):
    type: str = "ready"
    session_id: str


class PartialTranscriptMessage(BaseModel):
    type: str = "partial_transcript"
    text: str
    is_final: bool = False


class FinalTranscriptMessage(BaseModel):
    type: str = "final_transcript"
    text: str


class ResponseChunkMessage(BaseModel):
    type: str = "response_chunk"
    text: str
    accumulated: str


class ResponseCompleteMessage(BaseModel):
    type: str = "response_complete"
    text: str
    audio_url: str


class ErrorMessage(BaseModel):
    type: str = "error"
    code: str
    message: str


class SessionRestoredMessage(BaseModel):
    type: str = "session_restored"
    session_id: str
    pending_messages: List[Dict[str, Any]] = []
    state: str = "idle"
    partial_transcript: str = ""
    partial_response: str = ""


class ServerMessage(BaseModel):
    """Server-initiated message (proactive, follow-up, correction)."""
    type: str = "server_message"
    message_id: str
    text: str
    audio_url: Optional[str] = None
    reason: str = "follow_up"  # follow_up, correction, proactive, continuation


class ProcessingStatusMessage(BaseModel):
    """Progress update while processing a long request."""
    type: str = "processing_status"
    message: str
    elapsed_seconds: int


# =============================================================================
# WebSocket Manager
# =============================================================================

class WebSocketManager:
    """Manages WebSocket connections and message routing."""

    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.transcribers: Dict[str, ChunkedTranscriber] = {}
        self._cleanup_task: Optional[asyncio.Task] = None

    async def start_background_tasks(self):
        """Start background tasks like session cleanup."""
        if self._cleanup_task is None:
            self._cleanup_task = asyncio.create_task(
                start_cleanup_task(session_store, interval_seconds=300)
            )

    async def connect(self, websocket: WebSocket, session_id: Optional[str] = None):
        """
        Accept connection and set up session.
        If session_id is provided, attempt to restore existing session.
        """
        await websocket.accept()
        
        # Try to restore existing session or create new one
        session = None
        if session_id:
            session = await session_store.get_session(session_id)
            if session:
                logger.info(f"Restoring session: {session_id}")
        
        if not session:
            # Create new session
            session_id = await session_store.create_session()
            session = await session_store.get_session(session_id)
        
        self.active_connections[session_id] = websocket
        self.transcribers[session_id] = ChunkedTranscriber(
            chunk_duration_ms=3000,
            overlap_ms=500,
            model="base"
        )
        
        # If restoring, configure transcriber with saved format
        if session and session.audio_format:
            self.transcribers[session_id].set_format(session.audio_format)
        
        # Check for pending messages (indicates a restore with queued data)
        pending = await session_store.get_pending_messages(session_id)
        
        if pending:
            # Send session_restored with pending messages
            restored_msg = SessionRestoredMessage(
                session_id=session_id,
                pending_messages=pending,
                state=session.state if session else 'idle',
                partial_transcript=session.partial_transcript if session else '',
                partial_response=session.partial_response if session else '',
            )
            await websocket.send_json(restored_msg.dict())
            await session_store.clear_pending_messages(session_id)
            logger.info(f"Client reconnected with {len(pending)} pending messages: {session_id}")
        else:
            # Normal connection - send ready message
            ready_message = ReadyMessage(session_id=session_id)
            await websocket.send_json(ready_message.dict())
            logger.info(f"Client connected: {session_id}")
        
        return session_id

    async def reconnect(self, websocket: WebSocket, session_id: str) -> bool:
        """
        Handle client reconnection with existing session ID.
        Returns True if session was restored, False if new session needed.
        """
        session = await session_store.get_session(session_id)
        
        if not session:
            logger.info(f"Session not found for reconnect: {session_id}")
            return False
        
        # Update connection
        self.active_connections[session_id] = websocket
        
        # Restore transcriber
        if session_id not in self.transcribers:
            self.transcribers[session_id] = ChunkedTranscriber(
                chunk_duration_ms=3000,
                overlap_ms=500,
                model="base"
            )
            if session.audio_format:
                self.transcribers[session_id].set_format(session.audio_format)
        
        # Get pending messages
        pending = await session_store.get_pending_messages(session_id)
        
        # Send session restored message
        restored_msg = SessionRestoredMessage(
            session_id=session_id,
            pending_messages=pending,
            state=session.state,
            partial_transcript=session.partial_transcript,
            partial_response=session.partial_response,
        )
        await websocket.send_json(restored_msg.dict())
        
        # Clear pending messages after delivery
        await session_store.clear_pending_messages(session_id)
        
        logger.info(f"Session restored: {session_id} (pending={len(pending)})")
        return True

    async def disconnect(self, session_id: str):
        """
        Clean up WebSocket connection but preserve session state.
        Session can be restored on reconnect.
        """
        if session_id in self.active_connections:
            del self.active_connections[session_id]
        if session_id in self.transcribers:
            del self.transcribers[session_id]
        
        # Update session state to idle (but don't delete)
        await session_store.update_session(session_id, state='idle')
        logger.info(f"Client disconnected (session preserved): {session_id}")

    async def send_message(self, message: BaseModel, session_id: str) -> bool:
        """
        Send a message to a specific session.
        Returns True if sent successfully, False if client disconnected.
        """
        if session_id in self.active_connections:
            ws = self.active_connections[session_id]
            if ws.client_state == WebSocketState.CONNECTED:
                try:
                    await ws.send_json(message.dict())
                    return True
                except Exception as e:
                    logger.warning(f"Failed to send to {session_id}: {e}")
                    return False
        return False

    async def handle_json_message(self, websocket: WebSocket, session_id: str, data: Dict[str, Any]):
        """Route JSON messages to appropriate handlers."""
        msg_type = data.get("type")
        
        # Touch session on any activity
        await session_store.touch_session(session_id)
        
        try:
            if msg_type == "reconnect":
                # Client wants to restore a previous session
                reconnect_msg = ReconnectMessage(**data)
                success = await self.reconnect(websocket, reconnect_msg.session_id)
                if not success:
                    # Session expired or not found, send ready with new session
                    new_id = await session_store.create_session()
                    ready_message = ReadyMessage(session_id=new_id)
                    await websocket.send_json(ready_message.dict())
                return
                
            elif msg_type == "ack":
                # Client acknowledges receipt of a message
                ack_msg = AckMessage(**data)
                logger.debug(f"Ack received for message: {ack_msg.message_id}")
                return
                
            elif msg_type == "audio_start":
                audio_start = AudioStartMessage(**data)
                # Store format in session
                session = await session_store.get_session(session_id)
                if session:
                    await session_store.update_session(
                        session_id, 
                        audio_format=audio_start.format,
                        audio_buffer=b'',
                        state='recording'
                    )
                # Configure transcriber for this format
                if session_id in self.transcribers:
                    self.transcribers[session_id].set_format(audio_start.format)
                    self.transcribers[session_id].reset()
                logger.debug(f"Audio start: format={audio_start.format}")
                
            elif msg_type == "audio_end":
                session = await session_store.get_session(session_id)
                buffer_size = len(session.audio_buffer) if session else 0
                logger.debug(f"Audio end: {buffer_size} bytes buffered")
                await session_store.update_session(session_id, state='transcribing')
                await self._process_audio(session_id)
                
            elif msg_type == "text":
                text_msg = TextMessage(**data)
                logger.debug(f"Text received: {text_msg.content[:50]}...")
                await session_store.update_session(session_id, state='processing')
                await self._process_text(session_id, text_msg.content)
                
            elif msg_type == "cancel":
                logger.debug(f"Cancel received for {session_id}")
                await session_store.update_session(
                    session_id,
                    state='idle',
                    audio_buffer=b'',
                    partial_transcript='',
                    partial_response=''
                )
                
            else:
                logger.warning(f"Unknown message type: {msg_type}")
                await self.send_message(
                    ErrorMessage(code="unknown_type", message=f"Unknown message type: {msg_type}"),
                    session_id
                )
                
        except Exception as e:
            logger.exception(f"Error handling message: {e}")
            await self.send_message(
                ErrorMessage(code="message_error", message=str(e)),
                session_id
            )
            await session_store.update_session(session_id, state='idle')

    async def handle_binary(self, websocket: WebSocket, session_id: str, data: bytes):
        """Buffer incoming audio chunks in session store."""
        session = await session_store.get_session(session_id)
        if session:
            new_buffer = session.audio_buffer + data
            await session_store.update_session(session_id, audio_buffer=new_buffer)
            logger.debug(f"Audio chunk: {len(data)} bytes (total: {len(new_buffer)})")
        else:
            logger.warning(f"Received binary data for unknown session: {session_id}")

    async def _process_audio(self, session_id: str):
        """Process buffered audio - transcribe and generate response."""
        session = await session_store.get_session(session_id)
        if not session:
            logger.error(f"Session not found: {session_id}")
            return
            
        audio_data = session.audio_buffer
        audio_format = session.audio_format or "webm"
        
        if not audio_data:
            await self.send_message(
                ErrorMessage(code="no_audio", message="No audio data received"),
                session_id
            )
            return

        logger.info(f"Processing {len(audio_data)} bytes of {audio_format} audio")
        
        # Get or create transcriber
        transcriber = self.transcribers.get(session_id)
        if not transcriber:
            transcriber = ChunkedTranscriber()
            transcriber.set_format(audio_format)
            self.transcribers[session_id] = transcriber
        
        # Send partial transcript notification
        await self.send_message(
            PartialTranscriptMessage(text="Transcribing...", is_final=False),
            session_id
        )
        await session_store.update_session(session_id, partial_transcript="Transcribing...")
        
        # Feed all buffered audio to transcriber and finalize
        logger.info(f"Setting transcriber buffer with {len(audio_data)} bytes")
        transcriber.audio_buffer = bytearray(audio_data)
        logger.info(f"Transcriber buffer size: {len(transcriber.audio_buffer)} bytes")
        transcript = await transcriber.finalize()
        
        if not transcript:
            transcript = "[Could not transcribe audio]"
            
        logger.info(f"Transcribed: {transcript[:100]}...")
        
        # Store transcript in session
        await session_store.update_session(session_id, partial_transcript=transcript)
        
        # Send final transcript
        await self.send_message(
            FinalTranscriptMessage(text=transcript),
            session_id
        )
        
        # Process the transcript through chat
        await self._process_text(session_id, transcript)
        
        # Clear audio buffer
        await session_store.update_session(session_id, audio_buffer=b'')

    async def _process_text(self, session_id: str, text: str):
        """Process text input and generate response via OpenClaw.
        
        Supports multi-message responses: first message sent as response_complete,
        additional messages sent as server_message events with their own TTS.
        
        Sends progress updates every 10s for long-running requests.
        """
        import uuid
        
        logger.info(f"Processing text: {text[:50]}...")
        
        try:
            # Update state to processing
            await session_store.update_session(session_id, state='processing', partial_response='')
            
            # Add voice prefix so the agent knows input is spoken
            # This routes to the main session for unified context
            voice_text = f"[Voice PWA] {text}"
            
            # Progress callback for long-running requests
            async def on_progress(message: str, elapsed: int):
                status_msg = ProcessingStatusMessage(
                    message=message,
                    elapsed_seconds=elapsed
                )
                await self.send_message(status_msg, session_id)
                logger.info(f"Sent progress update to {session_id}: {message} ({elapsed}s)")
            
            # Get all response payloads from OpenClaw with progress updates
            payloads = await get_all_responses_with_progress(
                voice_text,
                progress_callback=on_progress,
                progress_interval=10,
                max_timeout=300
            )
            
            logger.info(f"Received {len(payloads)} payload(s) from OpenClaw")
            
            for i, payload in enumerate(payloads):
                response_text = payload.get("text", "")
                if not response_text:
                    continue
                
                # Generate TTS for this message
                audio_url = await self._generate_tts(response_text)
                logger.info(f"Generated TTS for message {i+1}/{len(payloads)}: {audio_url}")
                
                if i == 0:
                    # First message: send as response_complete
                    response_complete = ResponseCompleteMessage(
                        text=response_text,
                        audio_url=audio_url
                    )
                    
                    sent = await self.send_message(response_complete, session_id)
                    
                    if not sent:
                        await session_store.queue_message(session_id, response_complete.dict())
                    
                    logger.info(f"Sent response_complete with audio_url: {audio_url}")
                else:
                    # Additional messages: send as server_message
                    server_msg = ServerMessage(
                        message_id=str(uuid.uuid4()),
                        text=response_text,
                        audio_url=audio_url,
                        reason="continuation"
                    )
                    
                    sent = await self.send_message(server_msg, session_id)
                    
                    if not sent:
                        await session_store.queue_message(session_id, server_msg.dict())
                    
                    logger.info(f"Sent server_message {i+1}/{len(payloads)} with audio_url: {audio_url}")
                
                # Small delay between messages for better UX
                if i < len(payloads) - 1:
                    await asyncio.sleep(0.2)
            
            # Reset state
            await session_store.update_session(
                session_id, 
                state='idle',
                partial_response='',
                partial_transcript=''
            )
            
        except Exception as e:
            logger.exception(f"Error processing text: {e}")
            await self.send_message(
                ErrorMessage(code="processing_error", message=str(e)),
                session_id
            )
            await session_store.update_session(session_id, state='idle')

    async def _generate_tts(self, text: str) -> str:
        """Generate TTS audio for response text."""
        import uuid
        from pathlib import Path
        
        # Use the existing TTS setup from main.py
        audio_id = uuid.uuid4().hex
        output_dir = Path("audio_cache")
        output_dir.mkdir(exist_ok=True)
        output_file = output_dir / f"{audio_id}.wav"
        
        # Strip markdown and escape text for shell
        clean_text = strip_markdown(text)
        safe_text = clean_text.replace('"', '\\"').replace("'", "'\\''")
        
        # Piper TTS command
        piper_cmd = f'eval "$(pyenv init -)" && echo "{safe_text}" | piper -m /Users/rich/Projects/piper-models/en_US-lessac-medium.onnx -f {output_file}'
        
        try:
            process = await asyncio.create_subprocess_shell(
                piper_cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            await asyncio.wait_for(process.communicate(), timeout=30)
            
            if output_file.exists():
                return f"/voice/audio/{audio_id}.wav"
            else:
                logger.error("Piper did not produce output file")
                return "/voice/audio/error.wav"
                
        except Exception as e:
            logger.exception(f"TTS error: {e}")
            return "/voice/audio/error.wav"


# Singleton instance
websocket_manager = WebSocketManager()


# =============================================================================
# WebSocket Route
# =============================================================================

async def websocket_endpoint(websocket: WebSocket):
    """
    WebSocket endpoint for voice streaming.
    
    Protocol:
    1. Client connects (optionally with ?session_id=xxx to restore)
    2. Server sends {"type": "ready", "session_id": "..."} or {"type": "session_restored", ...}
    3. Client sends JSON messages or binary audio chunks
    4. Server streams responses back
    5. On disconnect, session is preserved for reconnection
    """
    import json
    
    # Start background tasks if not already running
    await websocket_manager.start_background_tasks()
    
    # Check for session_id in query params for reconnection
    query_session_id = websocket.query_params.get("session_id")
    
    # Connect (will restore session if valid session_id provided)
    session_id = await websocket_manager.connect(websocket, query_session_id)
    
    try:
        while True:
            # Use receive() to handle both text and binary
            message = await websocket.receive()
            
            if message["type"] == "websocket.receive":
                if "text" in message:
                    # JSON message
                    data = json.loads(message["text"])
                    
                    # Special handling for reconnect message
                    if data.get("type") == "reconnect":
                        new_session_id = data.get("session_id")
                        if new_session_id and new_session_id != session_id:
                            # Client wants to restore a different session
                            success = await websocket_manager.reconnect(websocket, new_session_id)
                            if success:
                                session_id = new_session_id
                                continue
                    
                    await websocket_manager.handle_json_message(websocket, session_id, data)
                elif "bytes" in message:
                    # Binary audio chunk
                    await websocket_manager.handle_binary(websocket, session_id, message["bytes"])
                    
            elif message["type"] == "websocket.disconnect":
                break
                
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected: {session_id}")
    except Exception as e:
        logger.exception(f"WebSocket error: {e}")
    finally:
        await websocket_manager.disconnect(session_id)


def register_websocket_routes(app: FastAPI):
    """Register WebSocket routes with the FastAPI app."""
    app.websocket("/voice/stream")(websocket_endpoint)
    logger.info("Registered WebSocket route: /voice/stream")
