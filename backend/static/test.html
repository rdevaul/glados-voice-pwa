<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voice Stream Test</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
      background: #1a1a2e;
      color: #eee;
    }
    h1 { color: #ff6b6b; margin-bottom: 5px; }
    .status {
      padding: 8px 12px;
      border-radius: 20px;
      display: inline-block;
      font-size: 14px;
      margin-bottom: 20px;
    }
    .status.disconnected { background: #e74c3c; }
    .status.connecting { background: #f39c12; }
    .status.ready { background: #27ae60; }
    .status.recording { background: #e74c3c; animation: pulse 1s infinite; }
    .status.processing { background: #3498db; }
    @keyframes pulse { 50% { opacity: 0.5; } }
    
    .section {
      background: #16213e;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 15px;
    }
    .section h3 { margin-top: 0; color: #a8dadc; }
    
    button {
      background: #4a69bd;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      margin-right: 10px;
      margin-bottom: 10px;
    }
    button:hover { background: #6a89cc; }
    button:disabled { background: #555; cursor: not-allowed; }
    button.danger { background: #e74c3c; }
    button.recording { background: #e74c3c; animation: pulse 0.5s infinite; }
    
    input[type="text"] {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      margin-bottom: 10px;
      background: #0f0f23;
      color: #eee;
    }
    
    .log {
      background: #0f0f23;
      padding: 10px;
      border-radius: 8px;
      height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 13px;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .log .in { color: #2ecc71; }
    .log .out { color: #3498db; }
    .log .err { color: #e74c3c; }
    .log .info { color: #95a5a6; }
    
    .response {
      background: #0f0f23;
      padding: 15px;
      border-radius: 8px;
      min-height: 60px;
      margin-top: 10px;
    }
    .transcript { color: #f39c12; font-style: italic; }
    .response-text { color: #2ecc71; }
    
    audio { width: 100%; margin-top: 10px; }
  </style>
</head>
<body>
  <h1>üéôÔ∏è Voice Stream Test</h1>
  <div class="status disconnected" id="status">Disconnected</div>
  
  <div class="section">
    <h3>Connection</h3>
    <button id="connectBtn" onclick="connect()">Connect</button>
    <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
  </div>
  
  <div class="section">
    <h3>Voice Input</h3>
    <button id="recordBtn" onclick="toggleRecording()" disabled>üé§ Hold to Record</button>
    <p style="font-size: 12px; color: #888;">Click and hold, or tap to start/stop</p>
  </div>
  
  <div class="section">
    <h3>Text Input</h3>
    <input type="text" id="textInput" placeholder="Type a message..." onkeypress="if(event.key==='Enter')sendText()">
    <button onclick="sendText()" id="sendBtn" disabled>Send</button>
  </div>
  
  <div class="section">
    <h3>Your Message (Transcription)</h3>
    <div id="transcript" class="response" style="background:#2d1f1f; min-height:40px; color:#f39c12;"></div>
  </div>
  
  <div class="section">
    <h3>GLaDOS Response</h3>
    <div id="responseText" class="response"></div>
    <audio id="audioPlayer" controls style="display:none;"></audio>
  </div>
  
  <div class="section">
    <h3>WebSocket Log</h3>
    <div class="log" id="log"></div>
    <button onclick="clearLog()" style="margin-top:10px; padding:8px 12px; font-size:12px;">Clear Log</button>
  </div>

<script>
const WS_URL = 'wss://glados.tailad67af.ts.net:8444/voice/stream';
const API_BASE = 'https://glados.tailad67af.ts.net:8444';

let ws = null;
let mediaRecorder = null;
let audioStream = null;
let isRecording = false;

const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');
const transcriptEl = document.getElementById('transcript');
const responseEl = document.getElementById('responseText');
const audioPlayer = document.getElementById('audioPlayer');

function setStatus(status) {
  statusEl.className = 'status ' + status;
  statusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
  
  document.getElementById('connectBtn').disabled = (status !== 'disconnected');
  document.getElementById('disconnectBtn').disabled = (status === 'disconnected');
  // Keep record button enabled during recording so user can stop it
  document.getElementById('recordBtn').disabled = (status !== 'ready' && status !== 'recording');
  document.getElementById('sendBtn').disabled = (status !== 'ready');
}

function log(type, msg) {
  const time = new Date().toLocaleTimeString();
  const line = document.createElement('div');
  line.className = type;
  line.textContent = `[${time}] ${msg}`;
  logEl.appendChild(line);
  logEl.scrollTop = logEl.scrollHeight;
}

function clearLog() {
  logEl.innerHTML = '';
}

function connect() {
  if (ws) return;
  
  setStatus('connecting');
  log('info', 'Connecting to ' + WS_URL);
  
  ws = new WebSocket(WS_URL);
  
  ws.onopen = () => {
    log('info', 'WebSocket connected');
  };
  
  ws.onmessage = (event) => {
    log('in', '‚Üê ' + event.data);
    
    try {
      const data = JSON.parse(event.data);
      handleMessage(data);
    } catch (e) {
      log('err', 'Failed to parse: ' + e);
    }
  };
  
  ws.onclose = () => {
    log('info', 'WebSocket closed');
    ws = null;
    setStatus('disconnected');
  };
  
  ws.onerror = (e) => {
    log('err', 'WebSocket error');
    console.error(e);
  };
}

function disconnect() {
  if (ws) {
    ws.close();
    ws = null;
  }
  setStatus('disconnected');
}

function handleMessage(data) {
  switch (data.type) {
    case 'ready':
      setStatus('ready');
      break;
      
    case 'partial_transcript':
      transcriptEl.textContent = 'üé§ ' + data.text;
      break;
      
    case 'final_transcript':
      transcriptEl.textContent = 'üìù ' + data.text;
      break;
      
    case 'response_chunk':
      responseEl.textContent = data.accumulated || data.text;
      setStatus('processing');
      break;
      
    case 'response_complete':
      responseEl.textContent = data.text;
      setStatus('ready');
      
      if (data.audio_url) {
        const audioUrl = API_BASE + data.audio_url;
        audioPlayer.src = audioUrl;
        audioPlayer.style.display = 'block';
        audioPlayer.play().catch(e => log('err', 'Autoplay blocked: ' + e));
      }
      break;
      
    case 'error':
      log('err', 'Server error: ' + data.message);
      setStatus('ready');
      break;
  }
}

function send(data) {
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    log('err', 'Not connected');
    return;
  }
  const msg = JSON.stringify(data);
  log('out', '‚Üí ' + msg);
  ws.send(msg);
}

function sendText() {
  const input = document.getElementById('textInput');
  const text = input.value.trim();
  if (!text) return;
  
  send({ type: 'text', content: text });
  input.value = '';
  setStatus('processing');
  
  // Clear previous response
  transcriptEl.textContent = '';
  responseEl.textContent = 'Processing...';
}

async function toggleRecording() {
  if (isRecording) {
    stopRecording();
  } else {
    await startRecording();
  }
}

async function startRecording() {
  try {
    audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    
    let mimeType = 'audio/webm';
    if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
      mimeType = 'audio/webm;codecs=opus';
    } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
      mimeType = 'audio/mp4';
    }
    
    mediaRecorder = new MediaRecorder(audioStream, { mimeType });
    
    // Send audio_start
    send({ type: 'audio_start', format: mimeType.split('/')[1].split(';')[0] });
    
    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0 && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(e.data);
        log('out', '‚Üí [binary ' + e.data.size + ' bytes]');
      }
    };
    
    mediaRecorder.start(250); // Send chunks every 250ms
    isRecording = true;
    setStatus('recording');
    
    const btn = document.getElementById('recordBtn');
    btn.textContent = '‚èπÔ∏è Stop Recording';
    btn.classList.add('recording');
    
    // Clear previous
    transcriptEl.textContent = 'üé§ Recording...';
    responseEl.textContent = '';
    
    log('info', 'Recording started (' + mimeType + ')');
    
  } catch (e) {
    log('err', 'Mic error: ' + e.message);
  }
}

function stopRecording() {
  if (!mediaRecorder || mediaRecorder.state === 'inactive') {
    return;
  }
  
  // Wait for final data before sending audio_end
  mediaRecorder.onstop = () => {
    log('info', 'MediaRecorder stopped, sending audio_end');
    
    if (audioStream) {
      audioStream.getTracks().forEach(t => t.stop());
      audioStream = null;
    }
    
    // Send audio_end after all chunks are flushed
    send({ type: 'audio_end' });
    
    transcriptEl.textContent = '‚è≥ Transcribing...';
  };
  
  // Request final data chunk
  mediaRecorder.requestData();
  mediaRecorder.stop();
  
  isRecording = false;
  setStatus('processing');
  
  const btn = document.getElementById('recordBtn');
  btn.textContent = 'üé§ Hold to Record';
  btn.classList.remove('recording');
  
  log('info', 'Recording stop requested...');
}

// Auto-connect on load
window.onload = () => {
  log('info', 'Test page loaded. Click Connect to start.');
};
</script>
</body>
</html>
