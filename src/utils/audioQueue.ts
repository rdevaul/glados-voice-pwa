/**
 * AudioQueue - Sequential audio playback utility.
 * Generated by qwen2.5-coder:32b, refined by GLaDOS.
 */

export type AudioQueueCallback = (url: string) => void;
export type AudioQueueErrorCallback = (error: Error, url: string) => void;
export type AudioQueueEmptyCallback = () => void;

export class AudioQueue {
  private queue: string[] = [];
  private audio: HTMLAudioElement;
  private _isPlaying: boolean = false;
  private _isPaused: boolean = false;
  private unlocked: boolean = false;
  private currentUrl: string | null = null;

  // Callbacks
  public onPlaybackStart?: AudioQueueCallback;
  public onPlaybackEnd?: AudioQueueCallback;
  public onQueueEmpty?: AudioQueueEmptyCallback;
  public onError?: AudioQueueErrorCallback;

  constructor() {
    this.audio = new Audio();
    this.audio.preload = 'auto';

    this.audio.onended = () => {
      if (this.currentUrl && this.onPlaybackEnd) {
        this.onPlaybackEnd(this.currentUrl);
      }
      this.currentUrl = null;
      this._isPlaying = false;
      this.playNext();
    };

    this.audio.onerror = () => {
      const error = new Error(`Failed to load audio: ${this.currentUrl}`);
      if (this.currentUrl && this.onError) {
        this.onError(error, this.currentUrl);
      }
      console.error('Audio playback error:', this.currentUrl, this.audio.error);
      this.currentUrl = null;
      this._isPlaying = false;
      // Skip to next on error
      this.playNext();
    };
  }

  /**
   * Call from a user gesture to unlock audio playback (Safari workaround).
   * Also retries any audio that was queued while autoplay was blocked.
   */
  public warmUp(): void {
    if (this.unlocked) {
      // Already unlocked — but the queue may have items waiting from when autoplay
      // was blocked (e.g. response arrived while tab was in background).
      // Use this user gesture opportunity to start playback.
      if (this.queue.length > 0 && !this._isPlaying && !this._isPaused) {
        this.playNext();
      }
      return;
    }

    // First time (or after autoplay rejection reset): unlock via silent audio
    const silentAudio = new Audio();
    silentAudio.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
    
    const playPromise = silentAudio.play();
    if (playPromise) {
      playPromise
        .then(() => {
          this.unlocked = true;
          silentAudio.pause();
          // If we have queued items waiting, start playing
          if (this.queue.length > 0 && !this._isPlaying) {
            this.playNext();
          }
        })
        .catch(() => {
          // Still blocked, will retry on next user gesture
        });
    }
  }

  /**
   * Add an audio URL to the queue.
   */
  public enqueue(url: string): void {
    this.queue.push(url);
    
    if (!this._isPlaying && !this._isPaused) {
      this.playNext();
    }
  }

  /**
   * Clear the queue and stop current playback.
   */
  public clear(): void {
    this.queue = [];
    this.audio.pause();
    this.audio.src = '';
    this.currentUrl = null;
    this._isPlaying = false;
    this._isPaused = false;
  }

  /**
   * Pause current playback.
   */
  public pause(): void {
    if (this._isPlaying) {
      this.audio.pause();
      this._isPaused = true;
      this._isPlaying = false;
    }
  }

  /**
   * Resume playback if paused.
   */
  public resume(): void {
    if (this._isPaused && this.currentUrl) {
      this._isPaused = false;
      this._isPlaying = true;
      this.audio.play().catch(err => {
        console.error('Failed to resume audio:', err);
        this._isPlaying = false;
      });
    } else if (!this._isPlaying && this.queue.length > 0) {
      this.playNext();
    }
  }

  /**
   * Skip to the next item in the queue.
   */
  public skip(): void {
    if (this._isPlaying || this._isPaused) {
      this.audio.pause();
      this._isPlaying = false;
      this._isPaused = false;
      this.playNext();
    }
  }

  /**
   * Whether audio is currently playing.
   */
  public get isPlaying(): boolean {
    return this._isPlaying;
  }

  /**
   * Whether audio is paused.
   */
  public get isPaused(): boolean {
    return this._isPaused;
  }

  /**
   * Number of items waiting in the queue.
   */
  public get queueLength(): number {
    return this.queue.length;
  }

  /**
   * Current playback time in seconds.
   */
  public get currentTime(): number {
    return this.audio.currentTime;
  }

  /**
   * Duration of current audio in seconds.
   */
  public get duration(): number {
    return this.audio.duration || 0;
  }

  private playNext(): void {
    if (this.queue.length === 0) {
      this._isPlaying = false;
      if (this.onQueueEmpty) {
        this.onQueueEmpty();
      }
      return;
    }

    const url = this.queue.shift()!;
    this.currentUrl = url;
    this.audio.src = url;
    
    if (this.onPlaybackStart) {
      this.onPlaybackStart(url);
    }

    const playPromise = this.audio.play();
    if (playPromise) {
      playPromise
        .then(() => {
          this._isPlaying = true;
          this.unlocked = true;
        })
        .catch(err => {
          console.warn('Autoplay blocked or failed:', err);
          this._isPlaying = false;
          
          if (err.name === 'NotAllowedError') {
            // Autoplay policy blocked playback (e.g. response arrived while tab was
            // in background, or user hasn't interacted yet).
            // Re-queue and reset unlock state so warmUp() on next user gesture retries.
            console.log('Autoplay blocked (NotAllowedError) — re-queuing for next user gesture');
            this.queue.unshift(url);
            this.unlocked = false;
          } else if (!this.unlocked) {
            // Never been unlocked — keep in queue for warmUp()
            this.queue.unshift(url);
          } else if (this.onError) {
            // Other error (e.g. network, bad URL) — skip and report
            this.onError(err, url);
          }
        });
    }
  }
}

// Singleton instance for app-wide use
let audioQueueInstance: AudioQueue | null = null;

export function getAudioQueue(): AudioQueue {
  if (!audioQueueInstance) {
    audioQueueInstance = new AudioQueue();
  }
  return audioQueueInstance;
}
